# shellcheck shell=sh disable=SC2039,SC1090,SC3043,SC2263    # xrc

___x_cmd_pkg___advise_ls_all_candidate(){
    candidate_exec_arr=( $(ls "$___X_CMD_PKG_RAWPATH"/*/ | awk '{if(($0 != "") && (! match($0, /^\/[..]*/))){print $0}}'))
}

___x_cmd_pkg___advise_ls_all_version(){
    local candidate_idx="${1:-2}"; [ -z "$ZSH_VERSION" ] || candidate_idx=$((candidate_idx+1))
    candidate_exec_arr=( $(___x_cmd_pkg_ls_all "${COMP_WORDS[candidate_idx]}"))
}

___x_cmd_pkg___adivse_ls_installed_version(){
    local candidate_idx="${1:-2}"; [ -z "$ZSH_VERSION" ] || candidate_idx=$((candidate_idx+1))
    candidate_exec_arr=( $(___x_cmd_pkg___advise_local_version "${COMP_WORDS[candidate_idx]}") )
}

___x_cmd_pkg___advise_ls_installed_name(){
    candidate_exec_arr=($(ls "$___X_CMD_PKG_INSTALL_PATH" | awk '{split($0,a," "); for(i in a)print a[i]}'))

}

___x_cmd_pkg___advise_ls_rawpath_version(){
    local candidate_idx="${1:-2}"; [ -z "$ZSH_VERSION" ] || candidate_idx=$((candidate_idx+1))
    candidate_exec_arr=( $(___x_cmd_pkg_ls_all "${COMP_WORDS[${candidate_idx}]}"))
}

___x_cmd_pkg___advise_local_version(){
    local "candidate=${1:-""}"
    candidate_exec_arr=( $(ls "$___X_CMD_PKG_INSTALL_PATH"/"$candidate"))
}


___x_cmd_pkg___advise_get_help_doc(){
    xrc ui
    subcmd=$(cat /home/mnnna/work/pkg/lib/pkg.advise.json | x ja 'D==2{print juq(K)"\n"}' | sort -u)
    cat /home/mnnna/work/pkg/lib/pkg.advise.json | awk -v subcmd=$subcmd -v LINES=$LINES -v COLUMNS=$COLUMNS "$(xrc cat awk/lib/jiter.awk; xrc cat awk/lib/json.awk; xrc cat awk/lib/default.awk)"'
    BEGIN{
    }
    {
        sublen = split(subcmd,subarr,"\n")
        for(z = 1; z <= sublen; ++z){
            if(match(subarr[z],"#")){delete subarr[z]; count++}
        }

        if ($0 != "") objlen = json_split2tokenarr(objarr, $0);
        for (i=1; i<=objlen; ++i){
            line =advise_json2help(objarr,objlen,i)
        }
        uniq(line,subarr)
    }

function advise_json2help(objarr,objlen,i,     tmp, _arr){

    objarr[i] = juq(objarr[i])
    if ((match (juq(objarr[i]),/^[A-Za-z]+/)) && (! match(objarr[i]," "))){
            v = objarr[i]
        }
    if (match (objarr[i],"#desc")) {desc = objarr[i+2]; }

    # if (tmp == "")   tmp = subcmd[v]
    if (match(objarr[i], "#1"))  { m = m SUBSEP objarr[i] }
    if (match(objarr[i], "#2"))  { m = m SUBSEP objarr[i]}
    if (match(objarr[i], "#3"))  { m = m SUBSEP objarr[i] }
    if((lastv != v)&&(lastdesc != desc)){
        k = lastv  m SUBSEP lastdesc; m = ""
        lastv = v
        lastdesc = desc
    }

        return k
}

function uniq(k,subarr,  current){
    current = k
    if ( k != last_version && k != "")  handledata(current,subarr)
    last_version =  current
}

function handledata(data,subarr,           arr,len,arrl){

    gsub("#1"," <candidate> ",data)
    gsub("#2"," <version> ",data)

    format(data,subarr)
}

function format(data,subarr,          _arr,i , j, spcae, complete, len){
    split( data, _arr, "\034" )
    for( _i in subarr){

        if ( _arr[1] == subarr[ _i ]){
            data = "<SUMCMD>" data "<color>"
        }
    }
    split( data, _arr , "\"")


    gsub( "\t" ,"" ,data )
    # split( data, _arr , "\"")

    if( length(_arr[ 1 ]) < COLUMNS ){

        len = 80 - length(_arr[ 1 ] )

        for( i = length( _arr[ 1 ] ); i < 80; ++i ){
            complete = complete  " "
        }
        data = _arr[ 1 ] complete jqu( _arr[ 2 ] ) _arr[3]
        gsub("\034", "",data)
        gsub("<SUMCMD>", "\t",data)
        gsub("<color>", "        ",data)
        if( _arr[ 2 ] != "")print data"\n"
        complete = ""
    }
}
    '
}