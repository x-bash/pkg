# shellcheck shell=sh disable=SC2039,SC1090,SC3043,SC2263    # xrc

___x_cmd_pkg___advise_ls_all_candidate(){
    candidate_exec_arr=( $(ls "$___X_CMD_PKG_RAWPATH"/*/ | awk '{if(($0 != "") && (! match($0, /^\/[..]*/))){print $0}}'))
}

___x_cmd_pkg___advise_ls_all_version(){
    local candidate_idx="${1:-2}"; [ -z "$ZSH_VERSION" ] || candidate_idx=$((candidate_idx+1))
    candidate_exec_arr=( $(___x_cmd_pkg_ls_all "${COMP_WORDS[candidate_idx]}"))
}

___x_cmd_pkg___adivse_ls_installed_version(){
    local candidate_idx="${1:-2}"; [ -z "$ZSH_VERSION" ] || candidate_idx=$((candidate_idx+1))
    candidate_exec_arr=( $(___x_cmd_pkg___advise_local_version "${COMP_WORDS[candidate_idx]}") )
}

___x_cmd_pkg___advise_ls_installed_name(){
    candidate_exec_arr=($(ls "$___X_CMD_PKG_INSTALL_PATH" | awk '{split($0,a," "); for(i in a)print a[i]}'))

}

___x_cmd_pkg___advise_ls_rawpath_version(){
    local candidate_idx="${1:-2}"; [ -z "$ZSH_VERSION" ] || candidate_idx=$((candidate_idx+1))
    candidate_exec_arr=( $(___x_cmd_pkg_ls_all "${COMP_WORDS[${candidate_idx}]}"))
}

___x_cmd_pkg___advise_local_version(){
    local "candidate=${1:-""}"
    candidate_exec_arr=( $(ls "$___X_CMD_PKG_INSTALL_PATH"/"$candidate"))
}


___x_cmd_pkg___advise_get_help_doc(){
    cat /home/mnnna/work/pkg/lib/pkg.advise.json | awk "$(xrc cat awk/lib/jiter.awk; xrc cat awk/lib/json.awk; xrc cat awk/lib/default.awk)"'
    BEGIN{

    }
    {
        if ($0 != "") objlen = json_split2tokenarr(objarr, $0);
        for (i=1; i<=objlen; ++i){
            line =advise_json2help(objarr,objlen,i)
        }
        uniq(line)
    }

function advise_json2help(objarr,objlen,i,     tmp, _arr){

    objarr[i] = juq(objarr[i])
    if ((match (juq(objarr[i]),/^[A-Za-z]+/)) && (! match(objarr[i]," "))){
            v = objarr[i]
        }
    if (match (objarr[i],"#desc")) {desc = objarr[i+2]; }

    # if (tmp == "")   tmp = subcmd[v]
    if (match(objarr[i], "#1"))  { m = m SUBSEP objarr[i] }
    if (match(objarr[i], "#2"))  { m = m SUBSEP objarr[i]}
    if (match(objarr[i], "#3"))  { m = m SUBSEP objarr[i] }
    if((lastv != v)&&(lastdesc != desc)){
        k = lastv  m SUBSEP lastdesc; m = ""
        lastv = v
        lastdesc = desc
    }

        return k
}

function uniq(k,v){
    current = k
    if ( k != last_version && k != "")  handledata(current)
    last_version =  current
}

function handledata(data,arr,len){
    # if (! match(data, "#")){
    #     if ((match(data,"|"))){
    #         len = split(data,arr,",")
    #         print "       "arr[1] "   ""<candidate>""   " arr[len]
    #     }else
    #         split(data,arr,",")
    #         print arr[1] "     " jqu(arr[2])
    # }
    # if (match(data,"#1")){
    #     len = split(data, arr, "#1")
    #     print arr[1] "   ""<candidate>""   " arr[len]
    # }
    # if (match(data,"#2")){
    #     len = split(data, arr, "#2")
    #     print arr[1] "   " "<candidate>" "   " "<version>" "  " arr[len]
    # }
    # gsub(SUBSEP,"    ",data)
    gsub("#1","<candidate>",data)
    gsub("#2","<version>",data)

    format(data)
}

function format(data,_arr,i , j, spcae, complete, len){
    # for(i=0; i < 20; ++i){
    #     space = space " "
    # }
    gsub("\t","",data)
    split(data, _arr , "\"")
    if( length(_arr[1]) < 80 ){
        len = 80 - length(_arr[1])
        for(i = length(_arr[1]); i <80; ++i){
            complete = complete  " "
        }
        data = _arr[1] complete jqu(_arr[2])
        if(_arr[2] != "")print data
        complete = ""
    }
}
    '
}








# ___x_cmd_pkg___advise_get_help_doc(){
#     cat /home/mnnna/work/pkg/lib/pkg.advise.json | awk "$(xrc cat awk/lib/jiter.awk; xrc cat awk/lib/json.awk; xrc cat awk/lib/default.awk)"'
#     {
#          if ($0 != "") jiparse_after_tokenize(obj, $0)
#         advise_json2help(obj)
#     }
# function advise_json2help(obj){
#     obj_prefix = SUBSEP "\"1\""
#     len = obj[obj_prefix L]
#     for (i = 1; i< len; ++i) print obj[obj_prefix i]
#     print len
# }
#     '
#  }

# ___x_cmd_advise_get_help(){
#     local filePath="${1:?"Provide advise json path"}"; [ "$#" -gt 0 ] && shift
#     local IFS
#     IFS="$(printf "\002")"
#     local s="$*"
#     if [ -f "$filePath" ]; then
#         ___x_cmd_advise_get_complete "$filePath" "$s" | awk "$(xrc cat awk/lib/default.awk)"'
#         {
#             $0 = juq($0)
#             _idx = index($0, ":")
#             if (_idx != 0) {
#                 _desc = substr($0, _idx+1)
#                 _str = arr[ _desc ]
#                 arr[ _desc ] = (_str != "") ? _str "|" substr($0, 1, _idx-1) : substr($0, 1, _idx-1)
#                 _l = length( arr[_desc] )
#                 arr_len[ _desc ] = _l
#                 if (_l > MAX_LEN) MAX_LEN = _l
#             }
#         }
#         END{
#             for ( i in arr ) print "    " arr[i]  sprintf("%" MAX_LEN - arr_len[ i ] "s", "") "  " i
#         }
#         '
#     fi
# }