# shellcheck shell=sh disable=SC2039,SC1090,SC3043,SC2263    # xrc

___x_cmd_pkg___advise_ls_all_candidate(){
    candidate_exec_arr=( $(___x_cmd_pkg_ls___all_candidate))
}

___x_cmd_pkg___advise_ls_all_version(){
    local candidate_idx="${1:-2}"; [ -z "$ZSH_VERSION" ] || candidate_idx=$((candidate_idx+1))
    candidate_exec_arr=( $(___x_cmd_pkg_ls_all "${COMP_WORDS[candidate_idx]}"))
}

___x_cmd_pkg___adivse_ls_installed_version(){
    local candidate_idx="${1:-2}"; [ -z "$ZSH_VERSION" ] || candidate_idx=$((candidate_idx+1))
    candidate_exec_arr=( $(___x_cmd_pkg___advise_local_version "${COMP_WORDS[candidate_idx]}") )
}

___x_cmd_pkg___advise_ls_installed_name(){
    candidate_exec_arr=($(ls "$___X_CMD_PKG_INSTALL_PATH" | awk '{split($0,a," "); for(i in a)print a[i]}'))
}

___x_cmd_pkg___advise_ls_rawpath_version(){
    local candidate_idx="${1:-2}"; [ -z "$ZSH_VERSION" ] || candidate_idx=$((candidate_idx+1))
    candidate_exec_arr=( $(___x_cmd_pkg_ls_all "${COMP_WORDS[${candidate_idx}]}"))
}

___x_cmd_pkg___advise_local_version(){
    local "candidate=${1:-""}"
    candidate_exec_arr=( $(ls "$___X_CMD_PKG_INSTALL_PATH"/"$candidate"))
}

___x_cmd_pkg___advise_deactivte_candidate(){
    candidate_exec_arr=($(printf "$___X_CMD_PKG_ACTIVATE___LIST" | awk '{split($0,a,"\n\n");for(i in a){split(a[i],b,"=");print b[1]} }'))
}

___x_cmd_pkg___advise_deactivte_version(){
    local candidate_idx="${1:-2}"; [ -z "$ZSH_VERSION" ] || candidate_idx=$((candidate_idx+1))
    candidate_exec_arr=(  $(
        printf "$___X_CMD_PKG_ACTIVATE___LIST" | awk -v candidate="${COMP_WORDS[candidate_idx]}" '
        {
            split( $0, a, "\n\n" )
            for(i in a){
                split(a[i],b,"=")
                if(match(candidate,b[1])){
                    print b[2]
                }
            }
        }'
    ))
}


___x_cmd_pkg___advise_get_help_doc(){
    xrc ui
    subcmd=$(cat /home/mnnna/work/pkg/lib/pkg.advise.json | x ja 'D==2{print juq(K)"\n"}' | sort -u)
    cat /home/mnnna/work/pkg/lib/pkg.advise.json | awk -v subcmd=$subcmd -v LINES=$LINES -v COLUMNS=$COLUMNS "$(xrc cat awk/lib/jiter.awk; xrc cat awk/lib/json.awk; xrc cat awk/lib/default.awk)"'
    BEGIN{
        for (i = 1; i <= 80; i++){space = space " "}
    }
    {
        sublen = split(subcmd,subarr,"\n")
        for(z = 1; z <= sublen; ++z){
            if(match(subarr[z],"#")){delete subarr[z]; count++}
        }

        if ($0 != "") objlen = json_split2tokenarr(objarr, $0);
        for (i=1; i<=objlen; ++i){
            line =advise_json2help(objarr,objlen,i)
        }
        uniq(line,subarr)
    }

function advise_json2help(objarr,objlen,i,     tmp, _arr){

    objarr[i] = juq(objarr[i])
    if ((match (juq(objarr[i]),/^[A-Za-z]+/)) && (! match(objarr[i]," "))){
            v = objarr[i]
        }
    if (match (objarr[i],"#desc")) {desc = objarr[i+2]; }

    # if (tmp == "")   tmp = subcmd[v]
    if (match(objarr[i], "#1"))  { m = m SUBSEP objarr[i] }
    if (match(objarr[i], "#2"))  { m = m SUBSEP objarr[i]}
    if (match(objarr[i], "#3"))  { m = m SUBSEP objarr[i] }
    if((lastv != v)&&(lastdesc != desc)){
        k = lastv  m SUBSEP lastdesc; m = ""
        lastv = v
        lastdesc = desc
    }

        return k
}

function uniq(k,subarr,  current){
    current = k
    if ( k != last_version && k != "")  handledata(current,subarr)
    last_version =  current
}

function handledata(data,subarr,           arr,len,arrl){

    gsub("#1"," <candidate> ",data)
    gsub("#2"," <version> ",data)

    format(data,subarr)
}

function format(data,subarr,          _arr,i , j, spcae, complete, len, line){
    split( data, _arr, "\034" )
    for( _i in subarr){

        if ( _arr[1] == subarr[ _i ]){
            data = "<SUMCMD>" data "<color>"
        }
    }
    split( data, _arr , "\"")


    gsub( "\t" ,"" ,data )
    # split( data, _arr , "\"")

    if( length(_arr[ 1 ]) < COLUMNS ){

        len = 80 - length(_arr[ 1 ] )

        for( i = length( _arr[ 1 ] ); i < 80; ++i ){
            complete = complete  " "
        }

    if (length( _arr[2]) + 80 > COLUMNS){
        lines = length(_arr[ 2 ])/(COLUMNS - 80 )
        if( lines > int(lines)){ lines = int(lines) + 1 }
print lines
# print "000" _arr[2] "000"
        desclength = COLUMNS -80
        # for (_k = 1; _k <= lines; _k++){
        #     if(_k == 1){
        #         ndesc = substr(_arr[2], 0,COLUMNS-1)
        #         indexnum = index(_arr[2],newdesc)
        #         newdesc = newdesc ndesc
        #     }else if(_k > 1 && k < lines){
        #         ndesc = substr(_arr[2], 0, COLUMNS-80)
        #         indexnum = index(_arr[2],newdesc)
        #         newdesc = newdesc "             "  ndesc
        #     }else{
        #         ndesc = substr(_arr[2], indexnum)
        #         newdesc = newdesc "             "  ndesc
        #     }
        # }
        for (_k = 1; _k <= lines; _k++){
            if(_k == 1){
                ndesc = substr(_arr[2], 0,COLUMNS)
                newdesc = newdesc ndesc"\n" "kkkk"
            }else if(_k > 1 && _k <= lines){
                 ndesc = substr(_arr[2], (COLUMNS-80)*(_k-1), COLUMNS-80)
                 newdesc = newdesc space ndesc"\n"
            }
            _arr[2] = newdesc
                # ndesc = substr(_arr[ 2 ], 0, desclength )

                # _arr[ 2 ] = substr(_arr[ 2 ],COLUMNS-80)

                # indexnum = index(_arr[2],ndesc)
                # print indexnum
                # _arr[2] = substr(_arr[2],)
                # newdesc = complete newdesc _arr[2]

        }


    }
        data = _arr[ 1 ] complete jqu( _arr[ 2 ] ) _arr[3]
        gsub("\034", "",data)
        gsub("<SUMCMD>", "\t",data)
        gsub("<color>", "        ",data)
        if( _arr[ 2 ] != "")print data"\n"
        complete = ""
    }
}
    '
}