
___x_cmd_pkg_install(){
    ___x_cmd_pkg_install___download "$@" || return
    if script="$(___x_cmd_pkg_install___get_install_script)"; then
        eval "$script"
    else
        ___x_cmd_pkg_install___unzip    "$@" || return
    fi
}

___x_cmd_pkg_reinstall(){
    :
}


___x_cmd_pkg_install___get_install_script(){
    : get the install script

}

# This is default
___x_cmd_pkg_install___unzip(){
    local pkg_name="${1:?Provide pkg name}"
    local version="${2:?rovide version}"

    local ball="$___X_CMD_PKG_DOWNLOAD_PATH/$pkg_name/$version"
    local tgt="$___X_CMD_PKG_INSTALL_PATH/$pkg_name/$version"

    x uz "$ball" "$tgt" || {
        pkg:warn "Fail to unzip $ball"
    }
}


# Section: download
___x_cmd_pkg_download(){
    local pkg_name="${1:?Provide pkg name}"
    local version="${2:?rovide version}"

    local url_list
    url_list="$(___x_cmd_pkg___bin_url_list "$@")"

    local url
    local ball="$___X_CMD_PKG_DOWNLOAD_PATH/$pkg_name/$version"
    while read -r url; do

        # Check MD5Sum. Whether it is already exists
        ___x_cmd_httpget "$url" "$ball" || {
            pkg:warn "Fail to download from $url"
            continue
        }
        # Check MD5Sum. If not. Deleted
    done <<A
$url_list
A

}

# Get bin list if zero argument
# Display path if arguments provided
# _bin_url__
# _bin_url_cn
___x_cmd_pkg___bin_url_list(){
    local pkg_name="${1:?Provide pkg name}"
    local version="${2:?rovide version}"
    local osarch="${3:-${___X_CMD_PKG_OSARCH:-$(___x_cmd_pkg_osarch)}}"

    ___x_cmd_pkg___all_info "${pkg_name}" | awk \
        -v osarch="$osarch" \
        -v version="$version" \
        -f "$___X_CMD_ROOT_MOD/awk/lib/default.awk" \
        -f "$___X_CMD_ROOT_MOD/awk/lib/jqparse.awk" \
        -f "awk/pkg.jobj.awk" \
        -f "awk/pkg.lsversion.awk"
}
# EndSection
